System.register(["../chunks/chunk-legacy-f8638e03.js"],(function(e,t){"use strict";var n;return{setters:[e=>{n=e._}],execute:function(){function e(e,t){let n;var i=Error.stackTraceLimit;return Error.stackTraceLimit=1/0,n=new Error(e),Error.stackTraceLimit=i,"undefined"!=typeof process&&process.cwd&&process.versions&&void 0!==process.versions.node&&process.release&&"node"===process.release.name&&(n.stack=function(e,t){if(!e)return e;const n=e.split(/\r?\n/);let i=0;const o=n.filter((e=>!(e.includes(" (internal/")||e.includes(" (node:internal")||i<t&&function(e){return e.startsWith("    at ")}(e)&&(i++,1)))).join("\n");return o}(n.stack,t)),n}function i(e,t){const n=globalThis[o]=globalThis[o]||{};return n[e]=n[e]||t}const o="_vike";function r(e){return"object"==typeof e&&null!==e}function s(e){return Array.from(new Set(e))}const a=i("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),l="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function c(){{const e=s(a.instances);!function(e,t){if(!e)throw new Error(`[vike][Wrong Usage] ${t}`)}(e.length<=1,`Both vike@${e[0]} and vike@${e[1]} loaded. Only one version should be loaded.`)}a.checkSingleInstance&&a.instances.length>1&&u(!1,l,{onlyOnce:!0,showStackTrace:!0})}function u(e,t,{onlyOnce:n,showStackTrace:i}){if(e)return;const o=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:e}=a,t=!0===n?o:n;if(e.has(t))return;e.add(t)}i?console.warn(new Error(o)):console.warn(o)}const f="0.4.165";var g;g=f,a.instances.push(g),c();const d=new Proxy((e=>e),{get:()=>d}),p=d,h=i("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){"info"===t?console.log(e):console.warn(e)},showStackTraceList:new WeakSet}),m="[vike]",y=`[vike@${f}]`,v=2;function x(t,n){if(t)return;const i=(()=>{if(!n)return null;const e="string"==typeof n?n:JSON.stringify(n);return p.dim(`Debug info (for Vike maintainers; you can ignore this): ${e}`)})();let o=["You stumbled upon a Vike bug.",`Go to ${p.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,i].filter(Boolean).join(" ");o=$(o),o=b(o,"Bug"),o=k(o,!0);const r=e(o,v);throw h.onBeforeLog?.(),r}function E(t,n,{showStackTrace:i}={}){if(t)return;const o=e(n=k(n=b(n=$(n),"Wrong Usage")),v);throw i&&h.showStackTraceList.add(o),h.onBeforeLog?.(),o}function w(e,t,{onlyOnce:n,showStackTrace:i}){if(!e){if(t=k(t=b(t=$(t),"Warning")),n){const{alreadyLogged:e}=h,i=!0===n?t:n;if(e.has(i))return;e.add(i)}if(h.onBeforeLog?.(),i){const e=new Error(t);h.showStackTraceList.add(e),h.logger(e,"warn")}else h.logger(t,"warn")}}function b(e,t){let n=`[${t}]`;const i="Warning"===t?"yellow":"red";return n=p.bold(p[i](n)),`${n}${e}`}function $(e){return e.startsWith("[")?e:` ${e}`}function k(e,t=!1){return`${t?y:m}${e}`}function F(){return"undefined"!=typeof window&&"number"==typeof window.scrollY}const C=i("utils/assertRouterType.ts",{}),P=["js","ts","cjs","cts","mjs","mts"],S=["vue","svelte","marko","md","mdx"],T=[...P,"jsx","tsx","cjsx","ctsx","mjsx","mtsx",...S];function N(e){const t=T.some((t=>e.endsWith("."+t)));return function(e){const t=/\.(c|m)?(j|t)s$/.test(e),n=P.some((t=>e.endsWith("."+t)));return x(t===n),t}(e)&&x(t),t}function j(e,t,n){return"string"==typeof e?_(e.split(""),t,n).join(""):_(e,t,n)}function _(e,t,n){const i=[];let o=t>=0?t:e.length+t;x(o>=0&&o<=e.length);let r=n>=0?n:e.length+n;for(x(r>=0&&r<=e.length);o!==r&&(o===e.length&&(o=0),o!==r);){const t=e[o];x(void 0!==t),i.push(t),o++}return i}const O=["http://","https://","tauri://"];function R(e,t){x(function(e){return O.some((t=>e.startsWith(t)))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||""===e}(e)),x(t.startsWith("/"));const[n,...i]=e.split("#");x(void 0!==n);const o=["",...i].join("#")||null;x(null===o||o.startsWith("#"));const r=null===o?"":L(o.slice(1)),[s,...a]=n.split("?");x(void 0!==s);const l=["",...a].join("?")||null;x(null===l||l.startsWith("?"));const c={},u={};Array.from(new URLSearchParams(l||"")).forEach((([e,t])=>{c[e]=t,u[e]=[...u.hasOwnProperty(e)?u[e]:[],t]}));const{origin:f,pathname:g}=function(e,t){x(!e.includes("?")&&!e.includes("#"));{const{origin:t,pathname:n}=W(e);if(t)return{origin:t,pathname:n};x(n===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const n="undefined"!=typeof window?window?.document?.baseURI:void 0;let i;i=n?W(n.split("?")[0]).pathname:t;const o=function(e,t){const n=t.split("/"),i=e.split("/");let o=t.endsWith("/");e.startsWith(".")&&n.pop();for(const s in i){const e=i[s];""==e&&"0"===s||"."!=e&&(".."==e?n.pop():(o=!1,n.push(e)))}let r=n.join("/");return o&&!r.endsWith("/")&&(r+="/"),r.startsWith("/")||(r="/"+r),r}(e,i);return{origin:null,pathname:o}}}(s,t);x(null===f||f===L(f)),x(g.startsWith("/")),x(null===f||e.startsWith(f));const d=s.slice((f||"").length);!function(e,t,n,i,o){const r=function(e,t,n,i){const o=`${e||""}${t}${n||""}${i||""}`;return o}(t,n,i,o);x(e===r)}(e,f,d,l,o);let{pathname:p,hasBaseServer:h}=function(e,t){(function(e){x(e.startsWith("/")),x(!e.includes("?")),x(!e.includes("#"))})(e),x(function(e){return e.startsWith("/")}(t));let n=e;if(x(n.startsWith("/")),x(t.startsWith("/")),"/"===t)return{pathname:e,hasBaseServer:!0};let i=t;return t.endsWith("/")&&n===j(t,0,-1)&&(i=j(t,0,-1),x(n===i)),n.startsWith(i)?(x(n.startsWith("/")||n.startsWith("http")),x(n.startsWith(i)),n=n.slice(i.length),n.startsWith("/")||(n="/"+n),x(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}(g,t);return p=p.replace(/\s+$/,"").split("/").map((e=>L(e).split("/").join("%2F"))).join("/"),x(p.startsWith("/")),{origin:f,pathname:p,pathnameOriginal:d,hasBaseServer:h,search:c,searchAll:u,searchOriginal:l,hash:r,hashOriginal:o}}function L(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function W(e){if(O.some((t=>e.startsWith(t)))){const[t,n,i,...o]=e.split("/");return{origin:[t,n,i].join("/"),pathname:["",...o].join("/")||"/"}}return{pathname:e,origin:null}}function V(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}function I(e){return e instanceof Function||"function"==typeof e}function z(e){return function(e){return(t,n)=>{const i=e(t),o=e(n);return x([!0,!1,null].includes(i)),x([!0,!1,null].includes(o)),i===o?0:!0===i||!1===o?-1:!0===o||!1===i?1:void x(!1)}}((t=>{const n=e(t);return null===n?null:!n}))}function A(e,t,n="unknown"){if(!r(e))return!1;if(!(t in e))return"undefined"===n;if("unknown"===n)return!0;const i=e[t];return"array"===n?Array.isArray(i):"object"===n?r(i):"string[]"===n?Array.isArray(i)&&i.every((e=>"string"==typeof e)):"function"===n?I(i):Array.isArray(n)?"string"==typeof i&&n.includes(i):"null"===n?null===i:"undefined"===n?void 0===i:"true"===n?!0===i:"false"===n?!1===i:typeof i===n}const D=e=>null!=e;function B(e){const t=e=>`Not a posix path: ${e}`;x(null!==e,t("null")),x("string"==typeof e,t(`typeof path === ${JSON.stringify(typeof e)}`)),x(""!==e,t("(empty string)")),x(e),x(!e.includes("\\"),t(e))}const G=["clientRouting"],U=["render","clientRouting","prerender","doNotPrerender"];function H(e,t,{definedAt:n}){const i=function(e,t){if("isComputed"in e)return"internally";let n;n="files"in e?e.files:[e],x(n.length>=1);const i=n.map((e=>{const{filePathToShowToUser:n,fileExportPathToShowToUser:i}=e;let o=n;const r=function(e,t){if(!e)return null;let[n,...i]=e;if(!n)return null;if(0===i.length&&["*","default",t].includes(n))return null;x("*"!==n);let o="",r="";return"default"===n?o="export default":(o="export",i=[n,...i]),i.forEach((e=>{o=`${o} { ${e}`,r=` }${r}`})),o+r}(i,t);return r&&(o=`${o} > ${p.cyan(r)}`),o})).join(" / ");return i}(n,t),o="internally"===i?i:`at ${i}`;let r=`${t}`;return`${e} ${p.cyan(r)} defined ${o}`}function M(e,t){const n={},i={},o={};e.forEach((e=>{const t=function(e){const{filePath:t,fileExports:n}=e;x(n),x(N(t));const i=[];return Object.entries(n).sort(z((([e])=>"default"===e))).forEach((([e,n])=>{let o="default"===e;if(o){if(!function(e){return S.some((t=>e.endsWith("."+t)))}(t))return E(r(n),`The ${p.cyan("export default")} of ${t} should be an object.`),void Object.entries(n).forEach((([e,n])=>{!function(e,t){E(!U.includes(e),`${t} has \`export default { ${e} }\` which is prohibited, use \`export { ${e} }\` instead.`)}(e,t),i.push({exportName:e,exportValue:n,isFromDefaultExport:o})}));e="Page"}i.push({exportName:e,exportValue:n,isFromDefaultExport:o})})),i.forEach((({exportName:e,isFromDefaultExport:t})=>{x(!(t&&U.includes(e)))})),i}(e);t.forEach((({exportName:t,exportValue:n,isFromDefaultExport:i})=>{x("default"!==t),o[t]=o[t]??[],o[t].push({exportValue:n,exportSource:`${e.filePath} > ${i?`\`export default { ${t} }\``:`\`export { ${t} }\``}`,filePath:e.filePath,_filePath:e.filePath,_fileType:e.fileType,_isFromDefaultExport:i})}))})),t&&Object.entries(t.configValues).forEach((([e,t])=>{const{value:r}=t,s=function({definedAt:e}){if("isComputed"in e||"files"in e)return null;const{filePathToShowToUser:t}=e;return x(t),t}(t),a=H("Config",e,t);i[e]=i[e]??r,n[e]=n[e]??[],x(0===n[e].length),n[e].push({configValue:r,configDefinedAt:a,configDefinedByFile:s});const l=e;o[l]=o[l]??[],o[l].push({exportValue:r,exportSource:a,filePath:s,_filePath:s,_fileType:null,_isFromDefaultExport:null})}));const s=new Proxy({},{get:(...e)=>(F()||w(!1,"`pageContext.pageExports` is outdated. Use `pageContext.exports` instead, see https://vike.dev/exports",{onlyOnce:!0,showStackTrace:!0}),Reflect.get(...e))}),a={};return Object.entries(o).forEach((([e,t])=>{t.forEach((({exportValue:t,_fileType:n,_isFromDefaultExport:i})=>{a[e]=a[e]??t,".page"!==n||i||e in s||(s[e]=t)}))})),x(!("default"in a)),x(!("default"in o)),{config:i,configEntries:n,exports:a,exportsAll:o,pageExports:s}}function Y(e){const t=".page.",n=j(e.split(t),0,-1).join(t);return x(!n.includes("\\")),n}function J(e){B(e)}function q(e,t){return x(!e.includes("\\")),e.includes("/_error")}const K=[".page",".page.server",".page.route",".page.client",".css"];function Q(e){const t=function(e){if(B(e),e.endsWith(".css"))return".css";x(N(e),e);const t=e.split("/").slice(-1)[0].split("."),n=t.slice(-3)[0],i=t.slice(-2)[0];return"page"===i?".page":(x("page"===n,e),"server"===i?".page.server":"client"===i?".page.client":"route"===i?".page.route":void x(!1,e))}(e),n={filePath:e,fileType:t,isEnv:e=>(x(".page.route"!==t),"CLIENT_ONLY"===e?".page.client"===t||".css"===t:"SERVER_ONLY"===e?".page.server"===t:"CLIENT_AND_SERVER"===e?".page"===t:void x(!1)),isRelevant:e=>n.pageId===e||n.isDefaultPageFile&&(Z(n.filePath)||function(e,t){J(e),J(t),x(!e.endsWith("/")),x(!t.endsWith("/")),x(X(t));const n=j(t.split("/"),0,-1).filter((e=>"_default"!==e)).join("/");return e.startsWith(n)}(e,n.filePath)),isDefaultPageFile:X(e),isRendererPageFile:".css"!==t&&X(e)&&Z(e),isErrorPageFile:q(e),pageId:Y(e)};return n}function X(e){return J(e),!q(e)&&e.includes("/_default")}function Z(e){return J(e),e.includes("/renderer/")}const ee=["$$registrations","_rerender_only"],te=[".md",".mdx"];function ne(e){const t={};e.filter((e=>"client"!==e.configName)).forEach((e=>{if(e.isValueFile){const{exportValues:n,importPath:i,configName:o}=e;!function(e,t,n){const i=Object.keys(e).filter((e=>!ee.includes(e))),o=i.filter((e=>"default"!==e&&e!==n));if(0===o.length){if(1===i.length)return;const e=p.cyan("export default"),o=p.cyan(`export { ${n} }`);0===i.length?E(!1,`${t} doesn't export any value, but it should have a ${o} or ${e}`):(x(2===i.length),w(!1,`${t} remove ${o} or ${e}`,{onlyOnce:!0}))}else{if(te.some((e=>t.endsWith(e))))return;o.forEach((e=>{w(!1,`${t} should have only one export: move ${p.cyan(`export { ${e} }`)} to its own +${o}.js file`,{onlyOnce:!0})}))}}(n,i,o),Object.entries(n).forEach((([n,o])=>{const r="default"!==n,s=r?n:e.configName;t[s]??(t[s]=[]),t[s].push({value:o,importPath:i,exportName:n,isSideExport:r})}))}else{const{configName:n,importPath:i,exportValue:o,exportName:r}=e;t[n]??(t[n]=[]),t[n].push({value:o,importPath:i,exportName:r,isSideExport:!1})}}));const n={};return Object.entries(t).forEach((([e,t])=>{const i=t.filter((e=>!e.isSideExport)),o=i.length>1,r=i.length===t.length;if(o)x(r),x(!1);else{const o=i[0]??t[0];x(o);const{value:r,importPath:s,exportName:a}=o;n[e]={value:r,definedAt:{filePathToShowToUser:s,fileExportPathToShowToUser:[e,"default"].includes(a)?[]:[a]}},function(e,t,n){x(!n.includes("+config."))}(0,0,s)}})),n}const ie=[{is:e=>void 0===e,match:e=>"!undefined"===e,serialize:()=>"!undefined",deserialize:()=>{}},{is:e=>e===1/0,match:e=>"!Infinity"===e,serialize:()=>"!Infinity",deserialize:()=>1/0},{is:e=>e===-1/0,match:e=>"!-Infinity"===e,serialize:()=>"!-Infinity",deserialize:()=>-1/0},{is:e=>"number"==typeof e&&isNaN(e),match:e=>"!NaN"===e,serialize:()=>"!NaN",deserialize:()=>NaN},{is:e=>e instanceof Date,match:e=>e.startsWith("!Date:"),serialize:e=>"!Date:"+e.toISOString(),deserialize:e=>new Date(e.slice(6))},{is:e=>"bigint"==typeof e,match:e=>e.startsWith("!BigInt:"),serialize:e=>"!BigInt:"+e.toString(),deserialize:e=>{if("undefined"==typeof BigInt)throw new Error("Your JavaScript environement does not support BigInt. Consider adding a polyfill.");return BigInt(e.slice(8))}},{is:e=>e instanceof RegExp,match:e=>e.startsWith("!RegExp:"),serialize:e=>"!RegExp:"+e.toString(),deserialize:e=>{const t=(e=e.slice(8)).match(/\/(.*)\/(.*)?/),n=t[1],i=t[2];return new RegExp(n,i)}},{is:e=>e instanceof Map,match:e=>e.startsWith("!Map:"),serialize:(e,t)=>"!Map:"+t(Array.from(e.entries())),deserialize:(e,t)=>new Map(t(e.slice(5)))},{is:e=>e instanceof Set,match:e=>e.startsWith("!Set:"),serialize:(e,t)=>"!Set:"+t(Array.from(e.values())),deserialize:(e,t)=>new Set(t(e.slice(5)))},{is:e=>"string"==typeof e&&e.startsWith("!"),match:e=>e.startsWith("!"),serialize:e=>"!"+e,deserialize:e=>e.slice(1)}];function oe(e){return re(JSON.parse(e))}function re(e){return"string"==typeof e?function(e){for(const{match:t,deserialize:n}of ie)if(t(e))return n(e,oe);return e}(e):("object"==typeof e&&null!==e&&Object.entries(e).forEach((([t,n])=>{e[t]=re(n)})),e)}function se(e){const t={};return Object.entries(e).forEach((([e,n])=>{const{valueSerialized:i,definedAt:o}=n;x(i),x(!t[e]),t[e]={value:oe(i),definedAt:o}})),t}function ae(e,t){const n=e.map((e=>{const t={};{const{configValuesSerialized:n}=e,i=se(n);Object.assign(t,i)}{const{configValuesImported:n}=e,i=ne(n);Object.assign(t,i)}const{pageId:n,isErrorPage:i,routeFilesystem:o,loadConfigValuesAll:r}=e;return function(e){const t="route",n=e[t];if(!n)return;const{value:i}=n,o=typeof i,r=H("Config",t,n);E("string"===o||I(i),`${r} has an invalid type '${o}': it should be a string or a function instead, see https://vike.dev/route`)}(t),{pageId:n,isErrorPage:i,routeFilesystem:o,configValues:t,loadConfigValuesAll:r}})),i={configValues:{}};{const e=ne(t.configValuesImported);Object.assign(i.configValues,e)}return{pageConfigs:n,pageConfigGlobal:i}}function le(e){x(A(e,"isGeneratedFile")),x(!1!==e.isGeneratedFile,"vike was re-installed(/re-built). Restart your app."),x(!0===e.isGeneratedFile,`\`isGeneratedFile === ${e.isGeneratedFile}\``),x(A(e,"pageFilesLazy","object")),x(A(e,"pageFilesEager","object")),x(A(e,"pageFilesExportNamesLazy","object")),x(A(e,"pageFilesExportNamesEager","object")),x(A(e.pageFilesLazy,".page")),x(A(e.pageFilesLazy,".page.client")||A(e.pageFilesLazy,".page.server")),x(A(e,"pageFilesList","string[]")),x(A(e,"pageConfigsSerialized")),x(A(e,"pageConfigGlobalSerialized"));const{pageConfigsSerialized:t,pageConfigGlobalSerialized:n}=e;!function(e){x(Array.isArray(e)),e.forEach((e=>{x(r(e)),x(A(e,"pageId","string")),x(A(e,"routeFilesystem")),x(A(e,"configValuesSerialized")),x(A(e,"configValuesImported"))}))}(t),function(e){x(A(e,"configValuesImported"))}(n);const{pageConfigs:i,pageConfigGlobal:o}=ae(t,n),s={};ce(e.pageFilesLazy).forEach((({filePath:e,pageFile:t,globValue:n})=>{t=s[e]=s[e]??t;const i=n;ue(i),t.loadFile=async()=>{"fileExports"in t||(t.fileExports=await i(),function(e){G.forEach((t=>{if(x(e.fileExports),!(t in e.fileExports))return;const n=`The value of \`${t}\` is only allowed to be \`true\`.`;E(!1!==e.fileExports[t],`${e.filePath} has \`export { ${t} }\` with the value \`false\` which is prohibited: remove \`export { ${t} }\` instead. (${n})`),E(!0===e.fileExports[t],`${e.filePath} has \`export { ${t} }\` with a forbidden value. ${n}`)}))}(t))}})),ce(e.pageFilesExportNamesLazy).forEach((({filePath:e,pageFile:t,globValue:n})=>{t=s[e]=s[e]??t;const i=n;ue(i),t.loadExportNames=async()=>{if(!("exportNames"in t)){const e=await i();E("exportNames"in e,"You seem to be using Vite 2 but the latest vike versions only work with Vite 3"),x(A(e,"exportNames","string[]"),t.filePath),t.exportNames=e.exportNames}}})),ce(e.pageFilesEager).forEach((({filePath:e,pageFile:t,globValue:n})=>{t=s[e]=s[e]??t;const i=n;x(r(i)),t.fileExports=i})),ce(e.pageFilesExportNamesEager).forEach((({filePath:e,pageFile:t,globValue:n})=>{t=s[e]=s[e]??t;const i=n;x(r(i)),x(A(i,"exportNames","string[]"),t.filePath),t.exportNames=i.exportNames})),e.pageFilesList.forEach((e=>{s[e]=s[e]??Q(e)}));const a=Object.values(s);return a.forEach((({filePath:e})=>{x(!e.includes("\\"))})),{pageFiles:a,pageConfigs:i,pageConfigGlobal:o}}function ce(e){const t=[];return Object.entries(e).forEach((([e,n])=>{x(K.includes(e)),x(r(n)),Object.entries(n).forEach((([n,i])=>{const o=Q(n);x(o.fileType===e),t.push({filePath:n,pageFile:o,globValue:i})}))})),t}function ue(e){x(I(e))}const fe=i("setPageFiles.ts",{});async function ge(e,t){e?(x(!fe.pageFilesGetter),x(void 0===t)):(x(fe.pageFilesGetter),x("boolean"==typeof t),fe.pageFilesAll&&t||await fe.pageFilesGetter());const{pageFilesAll:n,pageConfigs:i,pageConfigGlobal:o}=fe;x(n&&i&&o);const r=function(e,t){const n=s(e.filter((({isDefaultPageFile:e})=>!e)).map((({pageId:e})=>e))),i=t.map((e=>e.pageId));return[...n,...i]}(n,i);return{pageFilesAll:n,allPageIds:r,pageConfigs:i,pageConfigGlobal:o}}function de(e,t){return function(e,t,n){const i=n?"CLIENT_ONLY":"SERVER_ONLY",o=e.filter((e=>e.isRelevant(t)&&".page.route"!==e.fileType)).sort(function(e,t){const n=e?"CLIENT_ONLY":"SERVER_ONLY",i=-1,o=1,r=0;return(e,s)=>{if(!e.isDefaultPageFile&&s.isDefaultPageFile)return i;if(!s.isDefaultPageFile&&e.isDefaultPageFile)return o;{const t=e.isRendererPageFile,n=s.isRendererPageFile;if(!t&&n)return i;if(!n&&t)return o;x(t===n)}{const n=pe(t,e.filePath),r=pe(t,s.filePath);if(n<r)return i;if(r<n)return o;x(n===r)}return e.isEnv(n)&&s.isEnv("CLIENT_AND_SERVER")?i:s.isEnv(n)&&e.isEnv("CLIENT_AND_SERVER")?o:r}}(n,t)),r=e=>{const n=o.filter((n=>n.pageId===t&&n.isEnv(e?"CLIENT_AND_SERVER":i)));E(n.length<=1,`Merge the following files into a single file: ${n.map((e=>e.filePath)).join(" ")}`);const r=n[0];return x(void 0===r||!r.isDefaultPageFile),r},s=r(!1),a=r(!0),l=e=>o.filter((t=>t.isRendererPageFile&&t.isEnv(e?"CLIENT_AND_SERVER":i)))[0],c=l(!1),u=l(!0),f=o.filter((e=>e.isDefaultPageFile&&!e.isRendererPageFile&&(e.isEnv(i)||e.isEnv("CLIENT_AND_SERVER"))));return[s,a,...f,c,u].filter(D)}(e,t,!0)}function pe(e,t){J(e),J(t);let n=0;for(;n<e.length&&n<t.length&&e[n]===t[n];n++);const i=e.slice(n),o=t.slice(n);return i.split("/").length+o.split("/").length}const he={},me={},ye=[{pageId:"/src/pages/index",isErrorPage:void 0,routeFilesystem:{routeString:"/",definedBy:"/src/pages/index/"},loadConfigValuesAll:()=>n((()=>t.import("./src_pages_index-legacy.f474eb14.js")),void 0),configValuesSerialized:{isClientSideRenderable:{definedAt:{isComputed:!0},valueSerialized:"true"}},configValuesImported:[]}],ve={...Object.assign({})};he[".page"]=ve;const xe={...Object.assign({})};he[".page.client"]=xe;const Ee={...Object.assign({})};function we(e){const t=e/1e3;if(t<120){const e=be(t);return`${e} second${$e(e)}`}{const e=be(t/60);return`${e} minute${$e(e)}`}}function be(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function $e(e){return"1"===e?"":"s"}me[".page.server"]=Ee,function(e){const{pageFiles:t,pageConfigs:n,pageConfigGlobal:i}=le(e);fe.pageFilesAll=t,fe.pageConfigs=n,fe.pageConfigGlobal=i}(Object.freeze(Object.defineProperty({__proto__:null,isGeneratedFile:!0,neverLoaded:me,pageConfigGlobalSerialized:{configValuesImported:[]},pageConfigsSerialized:ye,pageFilesEager:{},pageFilesExportNamesEager:{},pageFilesExportNamesLazy:{},pageFilesLazy:he,pageFilesList:[]},Symbol.toStringTag,{value:"Module"})));const ke=i("utils/executeHook.ts",{userHookErrors:new WeakMap});function Fe(t,n){const{hookName:i,hookFilePath:o,hookTimeout:{error:s,warning:a}}=n;let l,c;const u=new Promise(((e,t)=>{l=t=>{f(),e(t)},c=e=>{f(),t(e)}})),f=()=>{g&&clearTimeout(g),d&&clearTimeout(d)},g=Ce(a)&&setTimeout((()=>{w(!1,`The ${i}() hook defined by ${o} is slow: it's taking more than ${we(a)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})}),a),d=Ce(s)&&setTimeout((()=>{const t=e(k(b($(`The ${i}() hook defined by ${o} timed out: it didn't finish after ${we(s)} (https://vike.dev/hooksTimeout)`),"Error")),v);c(t)}),s);return(async()=>{try{const e=await t();l(e)}catch(e){r(e)&&ke.userHookErrors.set(e,{hookName:i,hookFilePath:o}),c(e)}})(),u}function Ce(e){return!!e&&e!==1/0}function Pe(e){const t=window.location.href,{searchOriginal:n,hashOriginal:i,pathname:o}=R(t,"/");let r;return r=e?.withoutHash?`${o}${n||""}`:`${o}${n||""}${i||""}`,x(r.startsWith("/")),r}async function Se(e,t){if("isAllLoaded"in e&&!t)return e;const n=await e.loadConfigValuesAll();{const{configValuesImported:t}=n,i=ne(t);Object.assign(e.configValues,i)}{const{configValuesSerialized:t}=n,i=se(t);Object.assign(e.configValues,i)}return V(e,{isAllLoaded:!0}),e}x(F());const Te="__whileFetchingAssets";async function Ne(e,t,n){const i=de(t,e),o=function(e,t){const n=e.filter((e=>e.pageId===t));return x(n.length<=1),n[0]??null}(n,e);let r;try{r=(await Promise.all([o&&Se(o,!1),...i.map((e=>e.loadFile?.()))]))[0]}catch(f){throw function(e){return e instanceof Error&&["Failed to fetch dynamically imported module","error loading dynamically imported module","Importing a module script failed","error resolving module specifier","failed to resolve module"].some((t=>e.message.toLowerCase().includes(t.toLowerCase())))}(f)&&Object.assign(f,{[Te]:!0}),f}const{config:s,configEntries:a,exports:l,exportsAll:c,pageExports:u}=M(i,r);return{config:s,configEntries:a,exports:l,exportsAll:c,pageExports:u,_pageFilesLoaded:i}}const je=Pe({withoutHash:!0});async function _e(){const e=function(){const e="vike_pageContext",t=document.getElementById(e);E(t,`Couldn't find #${e} (which Vike automatically injects in the HTML): make sure it exists (i.e. don't remove it and make sure your HTML isn't malformed)`);const n=t.textContent;x(n);const i=oe(n);return x(A(i,"_pageId","string")),i}();return V(e,{isHydration:!0,isBackwardNavigation:null,_hasPageContextFromServer:!0,_hasPageContextFromClient:!1}),V(e,await async function(e){const t={},{pageFilesAll:n,pageConfigs:i}=await ge(!0);return V(t,{_pageFilesAll:n,_pageConfigs:i}),V(t,await Ne(e,t._pageFilesAll,t._pageConfigs)),n.filter((e=>".page.server"!==e.fileType)).forEach((e=>{w(!e.fileExports?.onBeforeRender,`export { onBeforeRender } of ${e.filePath} is loaded in the browser but never executed (because you are using Server-side Routing). In order to reduce the size of you browser-side JavaScript, define onBeforeRender() in a .page.server.js file instead, see https://vike.dev/onBeforeRender-isomorphic#server-routing`,{onlyOnce:!0})})),t}(e._pageId)),function(){const e=Pe({withoutHash:!0});E(je===e,`The URL was manipulated before the hydration finished ('${je}' to '${e}'). Ensure the hydration has finished before manipulating the URL. Consider using the onHydrationEnd() hook.`)}(),e}const Oe=i("getHook.ts",{isPrerendering:!1});function Re(e,t){if(!(t in e.exports))return null;const{hooksTimeout:n}=e.config,i=function(e,t){const n=function(e){if(void 0===e)return{};if(!1===e)return!1;E(r(e),`Setting ${p.cyan("hooksTimeout")} should be ${p.cyan("false")} or an object`);const t={};return Object.entries(e).forEach((([e,n])=>{if(!1===n)return void(t[e]={error:!1,warning:!1});E(r(n),`Setting ${p.cyan(`hooksTimeout.${e}`)} should be ${p.cyan("false")} or an object`);const[i,o]=["error","warning"].map((t=>{const i=n[t];if(void 0===i||!1===i)return i;const o=`Setting ${p.cyan(`hooksTimeout.${e}.${t}`)} should be`;return E("number"==typeof i,`${o} ${p.cyan("false")} or a number`),E(i>0,`${o} a positive number`),i}));t[e]={error:i,warning:o}})),t}(e);if(!1===n)return{error:!1,warning:!1};const i=n[t],o=function(e){return"onBeforeRoute"===e?{error:5e3,warning:1e3}:Oe.isPrerendering?{error:12e4,warning:3e4}:(x(!e.toLowerCase().includes("prerender")),{error:3e4,warning:4e3})}(t);return void 0!==i?.error&&(o.error=i.error),void 0!==i?.warning&&(o.warning=i.warning),o}(n,t),o=e.exports[t],s=e.exportsAll[t][0];if(x(s.exportValue===o),null===o)return null;const a=s.filePath;return x(a),x(!a.endsWith(" ")),function(e,{hookName:t,hookFilePath:n}){x(t&&n),x(!t.endsWith(")")),E(I(e),`Hook ${t}() defined by ${n} should be a function`)}(o,{hookName:t,hookFilePath:a}),{hookFn:o,hookName:t,hookFilePath:a,hookTimeout:i}}function Le(e){!function(e){(function(e,t){if(t.length>0){const n=t.find((t=>t.pageId===e));return x(n),!!n.isErrorPage}return q(e)})(e._pageId,e._pageConfigs)&&x(A(e,"is404","boolean"))}(e),function(e){if(void 0===e.is404||null===e.is404)return;const t=e.pageProps||{};r(t)?(t.is404=t.is404||e.is404,e.pageProps=t):w(!1,"pageContext.pageProps should be an object",{showStackTrace:!0,onlyOnce:!0})}(e)}const We="not-serializable",Ve=i("getPageContextProxyForUser.ts",{});function Ie(e){return x([!0,!1].includes(e._hasPageContextFromServer)),x([!0,!1].includes(e._hasPageContextFromClient)),new Proxy(e,{get(t,n){const i=e[n],o=JSON.stringify(n);return E(i!==We,`pageContext[${o}] couldn't be serialized and, therefore, is missing on the client-side. Check the server logs for more information.`),function(e,t){if(Ve.prev===t||"__v_raw"===Ve.prev)return;if(function(e){Ve.prev=e,window.setTimeout((()=>{Ve.prev=void 0}),0)}(t),t in e)return;if(function(e){return!!ze.includes(e)||"symbol"==typeof e||"string"!=typeof e||!!e.startsWith("__v_")}(t))return;if(!e._hasPageContextFromServer)return;const n=JSON.stringify(t);e._hasPageContextFromClient?w(!1,[`pageContext[${n}] isn't defined on the client-side:`,`1. if it's defined by the server-side then add ${n} to passToClient (https://vike.dev/passToClient), or`,"2. if it's expected that it may not be defined:","   ```js","   // ❌ Replace code like this:",`   const val = pageContext[${n}] ?? someDefaultValue`,"   // ✅ With that:",`   const val = ${n} in pageContext ? pageContext[${n}] : someDefaultValue`,"   ```",`See stack track below to find where pageContext[${n}] is being accessed.`].join("\n"),{showStackTrace:!0,onlyOnce:!1}):E(!1,`pageContext[${n}] isn't available on the client-side because ${n} is missing in passToClient, see https://vike.dev/passToClient`)}(e,n),i}})}const ze=["then","toJSON"];function Ae(e,t){if(t){const t=e;x([!0,!1].includes(t.isHydration)),x([!0,!1,null].includes(t.isBackwardNavigation))}else{const t=e;x(!0===t.isHydration),x(null===t.isBackwardNavigation)}x("config"in e),x("configEntries"in e),x("exports"in e),x("exportsAll"in e),x("pageExports"in e),x(r(e.pageExports)),V(e,{Page:e.exports.Page}),function(e){Object.entries(e).forEach((([t,n])=>{delete e[t],e[t]=n}))}(e),function(e){const t=Object.entries(e);for(const n in e)delete e[n];t.sort((([e],[t])=>{return i=t,(n=e).toLowerCase()<i.toLowerCase()?-1:n.toLowerCase()>i.toLowerCase()?1:0;var n,i})).forEach((([t,n])=>{e[t]=n}))}(e);const n=Ie(e);return Le(e),n}async function De(e,t){const n=Ae(e,t);let i,o=null;o=Re(e,"render"),i="render";{const t=Re(e,"onRenderClient");t&&(o=t,i="onRenderClient")}if(!o){const t=function(e){let t;try{t=e.urlPathname??e.urlOriginal}catch{}return t=t??window.location.href,t}(e);if(x(t),e._pageConfigs.length>0)E(!1,`No onRenderClient() hook defined for URL '${t}', but it's needed, see https://vike.dev/onRenderClient`);else{const n=e._pageFilesLoaded.filter((e=>".page.client"===e.fileType));let i;i=0===n.length?"No file `*.page.client.*` found for URL "+t:"One of the following files should export a render() hook: "+n.map((e=>e.filePath)).join(" "),E(!1,i)}}x(o);const r=o.hookFn;x(i),E(void 0===await Fe((()=>r(n)),o),`The ${i}() hook defined by ${o.hookFilePath} isn't allowed to return a value`)}var Be,Ge;Be=!0!==C.isClientRouting,E(F(),`${p.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),w(Be,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0}),C.isClientRouting=!1,Ge=!0,u(!0!==a.isClientRouting,"The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",{onlyOnce:!0,showStackTrace:!0}),u(void 0===a.isClientRouting,l,{onlyOnce:!0,showStackTrace:!0}),a.isClientRouting=!1,Ge&&(a.checkSingleInstance=!0),c(),async function(){const e=await _e();await De(e,!1),function(e,t){Re(e,t)}(e,"onHydrationEnd"),await(e.exports.onHydrationEnd?.(e))}()}}}));
